# MCP Apps Adapter

This adapter enables existing MCP-UI widgets to work in MCP Apps SEP environments by translating the MCP-UI protocol to JSON-RPC over postMessage.

## Overview

The MCP Apps adapter bridges the gap between:
- **MCP-UI Protocol**: The message format used by existing MCP-UI widgets
- **MCP Apps SEP Protocol**: The new JSON-RPC over postMessage protocol defined in [@modelcontextprotocol/ext-apps](https://github.com/modelcontextprotocol/ext-apps)

With the adapter, existing MCP-UI apps will run on MCP Apps compliant hosts. This facilitates gradual migration from legacy MCP-UI to the new spec (MCP Apps). MCP-UI's server SDK will soon support MCP Apps directly.

## Architecture

### Files

- **`adapter-runtime.ts`** - The actual TypeScript implementation with full type safety ✅
  - Edit this file to modify adapter behavior
  - Full TypeScript autocomplete, type checking, and refactoring support
  - Can be unit tested

- **`adapter-runtime.bundled.ts`** - Auto-generated bundled version
  - Generated by running `pnpm run bundle:adapter`
  - Self-contained script
  - **DO NOT EDIT THIS FILE DIRECTLY**

- **`adapter.ts`** - Wrapper that injects the bundled script
  - Imports the bundled runtime
  - Adds configuration
  - Returns injectable `<script>` tag

- **`types.ts`** - TypeScript type definitions for MCP-UI messages

- **`index.ts`** - Public exports

## Protocol Translation

### MCP-UI → MCP Apps (App to Host)

| MCP-UI Message | MCP Apps Method | Description |
|---------------|-----------------|-------------|
| `tool` | `tools/call` | Call a tool |
| `prompt` | `ui/message` | Send a follow-up message |
| `link` | `ui/open-link` | Open a URL |
| `notify` | `notifications/message` | Log a message |
| `intent` | `ui/message` | Send an intent (translated to message) |
| `ui-size-change` | `ui/notifications/size-change` | Resize the widget |
| `ui-lifecycle-iframe-ready` | `ui/notifications/initialized` | Signal widget is ready |

### MCP Apps → MCP-UI (Host to App)

| MCP Apps Notification | MCP-UI Message | Description |
|----------------------|----------------|-------------|
| `ui/notifications/tool-input` | `ui-lifecycle-iframe-render-data` | Tool arguments |
| `ui/notifications/tool-input-partial` | `ui-lifecycle-iframe-render-data` | Streaming tool arguments |
| `ui/notifications/tool-result` | `ui-lifecycle-iframe-render-data` | Tool execution result |
| `ui/notifications/host-context-changed` | `ui-lifecycle-iframe-render-data` | Theme, locale, viewport changes |

## Initialization Handshake

The adapter performs the MCP Apps SEP initialization handshake:

1. **Send `ui/initialize`** - Adapter sends its info and capabilities
2. **Receive response** - Host returns capabilities and context (theme, locale, viewport)
3. **Send `ui/notifications/initialized`** - Signal initialization complete
4. **Dispatch `ui-lifecycle-iframe-ready`** - Signal to MCP-UI widget that it's ready

## Development Workflow

### Editing the Adapter

1. Edit `adapter-runtime.ts` with full TypeScript support
2. Run `pnpm run bundle:adapter` to regenerate the bundled version
3. The bundled script is automatically regenerated before builds via `prebuild` hook

### Building

```bash
# Bundle the adapter runtime
pnpm run bundle:adapter

# Build the entire server SDK (automatically bundles first)
pnpm run build
```

### Testing

```bash
# Run adapter tests
pnpm test
```

## Usage

### Basic Usage with `createUIResource`

```typescript
import { createUIResource } from '@mcp-ui/server';

const uiResource = createUIResource({
  uri: 'ui://my-server/widget',
  content: {
    type: 'rawHtml',
    htmlString: '<div>My Widget</div>',
  },
  encoding: 'text',
  adapters: {
    mcpApps: {
      enabled: true,
    },
  },
});
```

### With Custom Configuration

```typescript
import { createUIResource } from '@mcp-ui/server';

const uiResource = createUIResource({
  uri: 'ui://my-server/widget',
  content: {
    type: 'rawHtml',
    htmlString: '<div>My Widget</div>',
  },
  encoding: 'text',
  adapters: {
    mcpApps: {
      enabled: true,
      config: {
        timeout: 60000, // 60 second timeout for async operations
      },
    },
  },
});
```

### Direct Script Injection

```typescript
import { getMcpAppsAdapterScript } from '@mcp-ui/server';

// Get injectable script
const script = getMcpAppsAdapterScript({
  timeout: 30000,
});

// Inject into HTML
const html = `<html><head>${script}</head><body>...</body></html>`;
```

### Registering a Tool with UI Resource

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { createUIResource, RESOURCE_URI_META_KEY } from '@mcp-ui/server';

const server = new McpServer({ name: 'my-server', version: '1.0.0' });

const widgetUI = createUIResource({
  uri: 'ui://my-server/widget',
  content: {
    type: 'rawHtml',
    htmlString: `
      <html>
        <body>
          <div id="app">Loading...</div>
          <script>
            window.addEventListener('message', (event) => {
              if (event.data.type === 'ui-lifecycle-iframe-render-data') {
                const { toolInput, toolOutput } = event.data.payload.renderData;
                document.getElementById('app').textContent = 
                  JSON.stringify({ toolInput, toolOutput });
              }
            });
            window.parent.postMessage({ type: 'ui-lifecycle-iframe-ready' }, '*');
          </script>
        </body>
      </html>
    `,
  },
  encoding: 'text',
  adapters: {
    mcpApps: { enabled: true },
  },
});

// Register the UI resource
server.registerResource(
  widgetUI.resource.uri,
  {},
  async () => widgetUI.resource
);

// Register the tool with _meta linking to the UI resource
// MCP Apps hosts look for RESOURCE_URI_META_KEY ('ui/resourceUri') in tool._meta
server.registerTool(
  'my_widget',
  {
    description: 'An interactive widget',
    inputSchema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'User query' }
      },
      required: ['query']
    },
    _meta: {
      [RESOURCE_URI_META_KEY]: widgetUI.resource.uri
    }
  },
  async ({ query }) => {
    return {
      content: [{ type: 'text', text: `Processing: ${query}` }],
    };
  }
);
```

## MIME Type

When the MCP Apps adapter is enabled, the resource MIME type is automatically set to `text/html+mcp`, which is the expected type for MCP Apps hosts.

## Mutual Exclusivity with Apps SDK Adapter

Only one adapter can be enabled at a time. The `AdaptersConfig` type enforces this at compile time:

```typescript
// ✅ Valid: Only MCP Apps adapter
adapters: { mcpApps: { enabled: true } }

// ✅ Valid: Only Apps SDK adapter
adapters: { appsSdk: { enabled: true } }

// ❌ Invalid: Both adapters (TypeScript error)
adapters: { mcpApps: { enabled: true }, appsSdk: { enabled: true } }
```

## Global API

The adapter exposes a global API for manual control:

```javascript
// Check if adapter is available
if (window.McpAppsAdapter) {
  // Manually initialize with default config
  window.McpAppsAdapter.init();
  
  // Initialize with the config from createUIResource
  window.McpAppsAdapter.initWithConfig();
  
  // Uninstall the adapter
  window.McpAppsAdapter.uninstall();
}

// Prevent auto-initialization
window.MCP_APPS_ADAPTER_NO_AUTO_INSTALL = true;
```

## Why This Architecture?

There are apps relying on MCP-UI in production. We want those apps to be supported by hosts that adopt the new spec (MCP Apps) until they can complete the migration. MCP-UI's server SDK will soon support MCP Apps directly.

## Related Resources

- [MCP Apps SEP Specification](https://github.com/modelcontextprotocol/ext-apps/blob/main/specification/draft/apps.mdx)
- [@modelcontextprotocol/ext-apps](https://github.com/modelcontextprotocol/ext-apps)
- [Apps SDK Adapter](../appssdk/README.md) - For ChatGPT/Apps SDK environments

